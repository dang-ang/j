<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisi Dati Team</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
      body {
        font-family: 'Inter', sans-serif;
      }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-8 flex flex-col items-center min-h-screen">

    <div class="max-w-4xl w-full bg-white rounded-xl shadow-2xl p-8 space-y-8">
        <h1 class="text-4xl font-bold text-center text-blue-600">Dashboard Analisi Dati Team</h1>
        <p class="text-center text-gray-600">Seleziona un giocatore, un parametro e un periodo per visualizzare l'andamento. Per confrontare un giocatore con la media del team, usa il primo pulsante. Per visualizzare tutti i giocatori, usa l'ultimo pulsante.</p>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <div class="flex flex-col">
                <label for="player-select" class="font-medium text-gray-700 mb-2">Seleziona Giocatore:</label>
                <select id="player-select" class="p-3 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                    <option value="" disabled selected>Seleziona un giocatore</option>
                </select>
            </div>

            <div class="flex flex-col">
                <label for="parameter-select" class="font-medium text-gray-700 mb-2">Seleziona Parametro:</label>
                <select id="parameter-select" class="p-3 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                    <option value="" disabled selected>Seleziona un parametro</option>
                </select>
            </div>

            <div class="flex flex-col">
                <label for="period-select" class="font-medium text-gray-700 mb-2">Seleziona Periodo:</label>
                <select id="period-select" class="p-3 border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                    <option value="all">Tutti i dati</option>
                    <option value="weekly">Settimanale</option>
                    <option value="monthly">Mensile</option>
                    <option value="custom">Personalizzato</option>
                </select>
            </div>
            
            <div id="custom-date-range" class="md:col-span-2 lg:col-span-3 flex flex-col md:flex-row gap-4 hidden">
                <div class="flex flex-col w-full">
                    <label for="start-date" class="font-medium text-gray-700 mb-2">Data di Inizio:</label>
                    <input type="date" id="start-date" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                </div>
                <div class="flex flex-col w-full">
                    <label for="end-date" class="font-medium text-gray-700 mb-2">Data di Fine:</label>
                    <input type="date" id="end-date" class="p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors">
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4">
            <button id="fetch-player-data" class="bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-blue-700 transition-all duration-300 ease-in-out transform hover:scale-105">
                Visualizza Giocatore vs. Team
            </button>
            <button id="fetch-team-data" class="bg-emerald-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-emerald-700 transition-all duration-300 ease-in-out transform hover:scale-105">
                Visualizza solo Team
            </button>
            <button id="fetch-all-players-data" class="bg-violet-600 text-white font-semibold py-3 px-6 rounded-lg shadow-lg hover:bg-violet-700 transition-all duration-300 ease-in-out transform hover:scale-105">
                Visualizza tutti i giocatori
            </button>
        </div>
        
        <div id="loading" class="flex justify-center items-center gap-2 text-blue-600 font-medium hidden">
            <svg class="animate-spin h-5 w-5 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Caricamento dati...
        </div>

        <div id="results-container" class="space-y-6 hidden">
            <h2 id="results-title" class="text-2xl font-bold text-gray-700 text-center"></h2>
            
            <div class="w-full max-w-full overflow-hidden bg-gray-50 rounded-lg p-4 shadow-inner">
                <canvas id="data-chart" class="w-full h-96"></canvas>
            </div>

            <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
                <table id="data-table" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider">Giocatore</th>
                            <th class="px-6 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider">Data</th>
                            <th class="px-6 py-3 text-left text-xs font-bold text-gray-500 uppercase tracking-wider">Valore</th>
                        </tr>
                    </thead>
                    <tbody id="table-body" class="bg-white divide-y divide-gray-200">
                        </tbody>
                </table>
            </div>
        </div>

        <div id="message-box" class="p-4 bg-red-100 text-red-700 rounded-lg hidden">
            </div>
    </div>
    


    
    <script>
        // Sostituisci questo URL con l'URL del tuo script di Google Apps
        const APP_SCRIPT_URL = "https://script.google.com/macros/s/AKfycby-14UNnIFbdh9-O0kNXnJNENYGy7OceIIBNJ_tTa1lZQOWgAuHgvHIrL68TOadoYNv/exec"; // Esempio: cambia per usare il tuo URL

        // Variabile per abilitare/disabilitare i dati fittizi
        // Imposta su 'false' quando vuoi usare il tuo script di Google Apps
        const useMockData = true;

        // Mappa i riferimenti agli elementi del DOM
        const playerSelect = document.getElementById('player-select');
        const parameterSelect = document.getElementById('parameter-select');
        const periodSelect = document.getElementById('period-select');
        const customDateRange = document.getElementById('custom-date-range');
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        const fetchPlayerDataBtn = document.getElementById('fetch-player-data');
        const fetchTeamDataBtn = document.getElementById('fetch-team-data');
        // Riferimento al nuovo bottone
        const fetchAllPlayersBtn = document.getElementById('fetch-all-players-data'); 
        const loadingSpinner = document.getElementById('loading');
        const resultsContainer = document.getElementById('results-container');
        const resultsTitle = document.getElementById('results-title');
        const tableBody = document.getElementById('table-body');
        const messageBox = document.getElementById('message-box');
        
        let chartInstance = null; // Riferimento all'istanza del grafico

        // Dati forniti dall'utente
        const players = [
            "AGRIGOROAEI", "AIT", "ARCIDIACONO", "BARUZZI", "BENALLAL", "BUSHI", "CENTANNI",
            "FALZONI", "FARINA", "FORESTIERO", "GALLALA", "GEMINIANI", "GIORDANO", "GNOFFO", "GRANO",
            "GRECA", "GUEYE", "IANIGRO","LANZA", "MASHA", "MHILLAJ", "NDOJ", "ZITOUNI"
        ];
        
        const parameters = [
            { name: "PRESENZE", type: "attendance" },
            { name: "Sforzo", type: "rpe" },
            { name: "Recupero", type: "recovery" },
            { name: "Stanchezza", type: "fatigue" },
            { name: "Peso", type: "weight" },
            { name: "Altezza", type: "height" },
            { name: "Balzo - alto", type: "balzo_alto" },
            { name: "Balzo - avanti", type: "balzo_avanti" },
            { name: "Velocità - 5mt", type: "speed_5" },
            { name: "Velocità - 20mt", type: "speed_20" },
            { name: "Velocità - 30mt", type: "speed_30" },
            { name: "Navetta - 15mt", type: "navetta_15" },
            { name: "Agilità [sec]", type: "agility" },
            { name: "Test Cooper - 6 min", type: "cooper_6" },
            { name: "Test Cooper - 12 min", type: "cooper_12" },
            { name: "Test Gacon", type: "gacon" }
        ];

        // Esegue il popolamento dei dropdown all'avvio della pagina
        document.addEventListener('DOMContentLoaded', populateDropdowns);

        /**
         * Funzione per popolare i menu a tendina con giocatori e parametri
         * hardcoded nel codice.
         */
        function populateDropdowns() {
            // Popola il menu a tendina dei giocatori
            playerSelect.innerHTML = '<option value="" disabled selected>Seleziona un giocatore</option>';
            players.forEach(player => {
                const option = document.createElement('option');
                option.value = player;
                option.textContent = player;
                playerSelect.appendChild(option);
            });

            // Popola il menu a tendina dei parametri
            parameterSelect.innerHTML = '<option value="" disabled selected>Seleziona un parametro</option>';
            parameters.forEach(param => {
                const option = document.createElement('option');
                option.value = param.type; // Usa il 'type' come valore della richiesta
                option.textContent = param.name; // Usa il 'name' come testo visualizzato
                parameterSelect.appendChild(option);
            });
        }
        
        // Event listener per mostrare/nascondere il selettore di date personalizzato
        periodSelect.addEventListener('change', () => {
            if (periodSelect.value === 'custom') {
                customDateRange.classList.remove('hidden');
            } else {
                customDateRange.classList.add('hidden');
            }
        });

        // Event listener per il bottone "Visualizza Giocatore vs. Team"
        fetchPlayerDataBtn.addEventListener('click', () => {
            clearState(); // Pulisce lo stato prima di ogni nuova richiesta
            const player = playerSelect.value;
            const parameterType = parameterSelect.value;
            const parameterName = parameterSelect.options[parameterSelect.selectedIndex].text;
            if (player && parameterType) {
                fetchPlayerAndTeamData(player, parameterType, parameterName);
            } else {
                displayMessage("Per favore, seleziona un giocatore e un parametro.", 'error');
            }
        });

        // Event listener per il bottone "Visualizza solo Team"
        fetchTeamDataBtn.addEventListener('click', async () => {
            clearState(); // Pulisce lo stato prima di ogni nuova richiesta
            const parameterType = parameterSelect.value;
            const parameterName = parameterSelect.options[parameterSelect.selectedIndex].text;
            
            if (!parameterType) {
                displayMessage("Per favore, seleziona un parametro.", 'error');
                return;
            }

            // Aggiungi un messaggio se un giocatore è selezionato ma si visualizza solo il team
            if (playerSelect.value) {
                displayMessage(`Visualizzazione dei dati del team, ignorando la selezione del giocatore '${playerSelect.value}'.`, 'info');
            } else {
                // Nascondi il messaggio se non c'è un giocatore selezionato
                messageBox.classList.add('hidden');
            }
            
            loadingSpinner.classList.remove('hidden');
            try {
                const period = periodSelect.value;
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const data = await fetchData('team', null, parameterType);
                const filteredData = filterAndAggregateData(data, period, startDate, endDate, 'Team');
                displayResults(filteredData, 'team', null, parameterName, period);
            } catch (error) {
                console.error("Errore nel recupero dei dati:", error);
                displayMessage(`Si è verificato un errore: ${error.message}`, 'error');
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        });

        // NUOVO EVENT LISTENER: per il bottone "Visualizza tutti i giocatori"
        fetchAllPlayersBtn.addEventListener('click', async () => {
            clearState();
            const parameterType = parameterSelect.value;
            const parameterName = parameterSelect.options[parameterSelect.selectedIndex].text;

            if (!parameterType) {
                displayMessage("Per favore, seleziona un parametro.", 'error');
                return;
            }

            loadingSpinner.classList.remove('hidden');
            try {
                const period = periodSelect.value;
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                // Richiesta per i dati di tutti i giocatori (come se fosse un 'team' ma senza aggregazione)
                const data = await fetchData('team', null, parameterType); 
                const filteredData = processAllPlayersData(data, period, startDate, endDate);
                displayAllPlayersResults(filteredData, parameterName, period);
            } catch (error) {
                console.error("Errore nel recupero dei dati di tutti i giocatori:", error);
                displayMessage(`Si è verificato un errore: ${error.message}`, 'error');
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        });

        /**
         * Pulisce lo stato dell'interfaccia utente, nascondendo i risultati e i messaggi
         * e distruggendo l'istanza del grafico.
         */
        function clearState() {
            resultsContainer.classList.add('hidden');
            messageBox.classList.add('hidden');
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
        }


        /**
         * Funzione principale per il recupero dei dati di giocatore e team.
         * @param {string} player - Il nome del giocatore.
         * @param {string} parameterType - Il nome del foglio di calcolo per il parametro.
         * @param {string} parameterName - Il nome descrittivo del parametro.
         */
        async function fetchPlayerAndTeamData(player, parameterType, parameterName) {
            loadingSpinner.classList.remove('hidden');

            const period = periodSelect.value;
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;

            try {
                // Esegue entrambe le chiamate in parallelo
                const [playerResponse, teamResponse] = await Promise.all([
                    fetchData('player', player, parameterType),
                    fetchData('team', null, parameterType)
                ]);

                // Controlla che le risposte siano array validi prima di procedere
                if (!Array.isArray(playerResponse) || !Array.isArray(teamResponse)) {
                    throw new Error("Errore nel formato dei dati ricevuti dal server.");
                }

                // Processa i dati individualmente
                const playerFilteredData = filterAndAggregateData(playerResponse, period, startDate, endDate, player);
                const teamFilteredData = filterAndAggregateData(teamResponse, period, startDate, endDate, 'Team');

                // Passa entrambi i set di dati alla funzione di visualizzazione
                displayComparisonResults(playerFilteredData, teamFilteredData, player, parameterName, period);

            } catch (error) {
                console.error("Errore nel recupero dei dati:", error);
                displayMessage(`Si è verificato un errore: ${error.message}`, 'error');
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }
        
        /**
         * Funzione principale per il recupero dei dati dallo script di Google Apps.
         * Ora restituisce solo i dati, lasciando la gestione della visualizzazione alle funzioni chiamanti.
         * @param {string} scope - "player" o "team" per determinare l'ambito della richiesta.
         * @param {string} player - Il nome del giocatore (o null per il team).
         * @param {string} parameterType - Il nome del foglio di calcolo per il parametro.
         * @returns {Promise<Array>} - Una Promise che risolve con l'array dei dati.
         */
        async function fetchData(scope, player, parameterType) {
            if (useMockData) {
                // Usa i dati fittizi
                return getMockData(parameterType, scope === 'player' ? player : null);
            } else {
                // Costruisce l'URL della richiesta utilizzando il nome del foglio (type)
                let url = `${APP_SCRIPT_URL}?parameter=${encodeURIComponent(parameterType)}`;
                if (scope === 'player') {
                    url += `&player=${encodeURIComponent(player)}`;
                } else if (scope === 'team') {
                    url += `&player=team`;
                }

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Errore di rete: ${response.status}`);
                    }
                    const data = await response.json();
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    return data;
                } catch (error) {
                    console.error("Errore nel recupero dei dati:", error);
                    throw error; // Rilancia l'errore per essere gestito dalla funzione chiamante
                }
            }
        }


        /**
         * Funzione che genera dati fittizi per testare l'interfaccia.
         * Simula la risposta JSON attesa dallo script di Google Apps.
         * @param {string} parameter - Il nome del foglio (type).
         * @param {string} player - Il nome del giocatore (o null).
         * @returns {Array} - Un array di oggetti con i dati.
         */
        function getMockData(parameter, player) {
            const today = new Date();
            const mockData = [];
            // Simula il caso in cui un giocatore selezionato non ha dati
            if (player && player === "NDOJ") {
                return []; 
            }
            const playersList = player && player !== 'team' ? [player] : players;
            
            // Genera dati fittizi per 10 giorni, per diversi giocatori
            for (let i = 0; i < 10; i++) {
                const date = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate() - i));
                const dateString = `${String(date.getUTCDate()).padStart(2, '0')}-${String(date.getUTCMonth() + 1).padStart(2, '0')}-${date.getUTCFullYear()}`;

                playersList.forEach(p => {
                    let value;
                    // Genera valori casuali in base al parametro
                    switch (parameter) {
                        case 'attendance':
                            value = Math.random() > 0.3 ? 1 : 0; // 70% di probabilità di presenza
                            break;
                        case 'rpe':
                            // Simula più valori per lo stesso giorno per testare l'aggregazione
                            const numValues = Math.floor(Math.random() * 3) + 1; // 1 a 3 valori
                            for (let j = 0; j < numValues; j++) {
                                value = (Math.random() * 10).toFixed(1);
                                mockData.push({
                                    player: p,
                                    data: dateString,
                                    valore: value
                                });
                            }
                            return; // Salta il push finale per evitare duplicati
                        case 'recovery':
                            value = (Math.random() * 5).toFixed(1);
                            break;
                        case 'fatigue':
                            value = (Math.random() * 5).toFixed(1);
                            break;
                        case 'weight':
                            value = (Math.random() * 5 + 70).toFixed(1); // Peso tra 70 e 75 kg
                            break;
                        case 'height':
                            value = (Math.random() * 20 + 170).toFixed(0); // Altezza tra 170 e 190 cm
                            break;
                        default:
                            value = (Math.random() * 100).toFixed(1);
                    }
                    mockData.push({
                        player: p,
                        data: dateString,
                        valore: value
                    });
                });
            }
            return mockData;
        }

        /**
         * Filtra e aggrega i dati in base al periodo selezionato.
         * @param {Array} data - I dati grezzi ricevuti dallo script.
         * @param {string} period - Il periodo di aggregazione ("all", "weekly", "monthly", "custom").
         * @param {string} startDate - Data di inizio per il periodo personalizzato.
         * @param {string} endDate - Data di fine per il periodo personalizzato.
         * @param {string} playerLabel - L'etichetta da usare per il giocatore/team.
         * @returns {Array} - I dati filtrati e aggregati.
         */
        function filterAndAggregateData(data, period, startDate, endDate, playerLabel) {
            let filteredData = data;
            // Filtra per il periodo personalizzato se specificato
            if (period === 'custom' && startDate && endDate) {
                const start = parseDate(startDate);
                const end = parseDate(endDate);
                filteredData = data.filter(item => {
                    const itemDate = parseDate(item.data); 
                    return itemDate >= start && itemDate <= end;
                });
            }

            if (filteredData.length === 0) {
                return [];
            }
            
            const groupedData = {};
            filteredData.forEach(item => {
                const date = parseDate(item.data);
                if (!date) return; // Salta le date non valide

                let key = '';
                let displayDate = '';
                let sortableDate = date.toISOString(); // Data ordinabile predefinita

                if (period === 'weekly') {
                    const startOfWeek = new Date(date);
                    // Regola l'inizio della settimana al lunedì (ISO 8601)
                    const day = (startOfWeek.getUTCDay() === 0) ? 6 : startOfWeek.getUTCDay() - 1; // 0 per lunedì, ..., 6 per domenica
                    startOfWeek.setUTCDate(startOfWeek.getUTCDate() - day);
                    sortableDate = startOfWeek.toISOString();
                    displayDate = getWeekNumberAndRange(startOfWeek);
                    key = sortableDate;
                } else if (period === 'monthly') {
                    key = `${date.getUTCFullYear()}-${date.getUTCMonth()}`;
                    sortableDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1)).toISOString();
                    displayDate = formatDateToAbbreviatedMonth(date);
                } else {
                    // Aggrega i dati per ogni giorno per il periodo "all"
                    key = date.toISOString();
                    displayDate = formatDateTo_ddMMyyyy(date);
                }

                if (!groupedData[key]) {
                    groupedData[key] = { valori: [], players: new Set(), displayDate: displayDate, sortableDate: sortableDate };
                }
                const parsedValue = parseFloat(item.valore);
                if (!isNaN(parsedValue)) {
                    groupedData[key].valori.push(parsedValue);
                }
                groupedData[key].players.add(item.player);
            });

            const aggregatedData = Object.entries(groupedData).map(([key, value]) => {
                const sum = value.valori.reduce((total, num) => total + num, 0);
                const count = value.valori.length;
                const average = count > 0 ? (sum / count).toFixed(2) : 'N/A';

                return {
                    data: value.displayDate || key,
                    valore: average,
                    player: playerLabel,
                    sortableDate: value.sortableDate
                };
            });

            // Ordina i dati aggregati utilizzando la data sortable
            return aggregatedData.sort((a, b) => new Date(a.sortableDate) - new Date(b.sortableDate));
        }

        // NUOVA FUNZIONE: Processa i dati senza aggregare i giocatori
        function processAllPlayersData(data, period, startDate, endDate) {
            let filteredData = data;
            // Filtra per il periodo personalizzato se specificato
            if (period === 'custom' && startDate && endDate) {
                const start = parseDate(startDate);
                const end = parseDate(endDate);
                filteredData = data.filter(item => {
                    const itemDate = parseDate(item.data);
                    return itemDate >= start && itemDate <= end;
                });
            }

            if (filteredData.length === 0) {
                return [];
            }
            
            // Ordina i dati filtrati per data e poi per nome del giocatore per consistenza
            return filteredData.sort((a, b) => {
                const dateA = parseDate(a.data);
                const dateB = parseDate(b.data);
                if (dateA - dateB !== 0) {
                    return dateA - dateB;
                }
                return a.player.localeCompare(b.player);
            });
        }


        /**
         * Visualizza i dati in una tabella e in un grafico (per un singolo dataset).
         * @param {Array} data - I dati da visualizzare.
         * @param {string} scope - "player" o "team".
         * @param {string} player - Il nome del giocatore.
         * @param {string} parameterName - Il nome descrittivo del parametro.
         * @param {string} period - Il periodo di visualizzazione.
         */
        function displayResults(data, scope, player, parameterName, period) {
            // Controlla se non ci sono dati e nasconde il container in tal caso
            if (data.length === 0) {
                resultsContainer.classList.add('hidden');
                displayMessage("Nessun dato trovato per la selezione corrente.", 'info');
                return;
            }
            
            resultsContainer.classList.remove('hidden');
            
            // Aggiorna il titolo
            if (scope === 'player') {
                resultsTitle.textContent = `Andamento di ${player} per il parametro "${parameterName}"`;
            } else {
                resultsTitle.textContent = `Andamento del Team per il parametro "${parameterName}"`;
            }
            
            // Popola la tabella
            tableBody.innerHTML = '';
            data.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${item.player}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${item.data}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${item.valore}</td>
                `;
                tableBody.appendChild(row);
            });

            // Visualizza il grafico
            renderChart(data, scope, period);
        }

        /**
         * Visualizza i dati di confronto (giocatore vs. team) in una tabella e in un grafico.
         * @param {Array} playerData - Dati del giocatore.
         * @param {Array} teamData - Dati del team.
         * @param {string} player - Il nome del giocatore.
         * @param {string} parameterName - Il nome descrittivo del parametro.
         * @param {string} period - Il periodo di visualizzazione.
         */
        function displayComparisonResults(playerData, teamData, player, parameterName, period) {
            // Se non ci sono dati del giocatore, mostra solo i dati del team
            if (playerData.length === 0) {
                 displayMessage(`Nessun dato trovato per il giocatore '${player}'. Visualizzazione dei dati del team.`, 'info');
                 displayResults(teamData, 'team', null, parameterName, period);
                 return;
            }

            // Controlla se non ci sono dati in entrambi gli array e nasconde il container in tal caso
            if (playerData.length === 0 && teamData.length === 0) {
                resultsContainer.classList.add('hidden');
                displayMessage("Nessun dato trovato per la selezione corrente.", 'info');
                return;
            }
            
            resultsContainer.classList.remove('hidden');

            // Aggiorna il titolo
            resultsTitle.textContent = `Confronto tra ${player} e Team per il parametro "${parameterName}"`;
            
            // Popola la tabella con entrambi i set di dati
            tableBody.innerHTML = '';
            
            // Unisce i dati e popola la tabella. Ordina per data per visualizzare in modo coerente
            const combinedData = [...playerData, ...teamData].sort((a, b) => new Date(a.sortableDate) - new Date(b.sortableDate));
            combinedData.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${item.player}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${item.data}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${item.valore}</td>
                `;
                tableBody.appendChild(row);
            });

            // Visualizza il grafico con due linee
            renderComparisonChart(playerData, teamData, player, period);
        }

        // NUOVA FUNZIONE: Visualizza i dati di tutti i giocatori in una tabella e in un grafico multi-linea
        function displayAllPlayersResults(data, parameterName, period) {
            if (data.length === 0) {
                resultsContainer.classList.add('hidden');
                displayMessage("Nessun dato trovato per la selezione corrente.", 'info');
                return;
            }

            resultsContainer.classList.remove('hidden');
            resultsTitle.textContent = `Andamento di tutti i giocatori per il parametro "${parameterName}"`;

            // Popola la tabella con tutti i dati individuali
            tableBody.innerHTML = '';
            data.forEach(item => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${item.player}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${item.data}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${item.valore}</td>
                `;
                tableBody.appendChild(row);
            });

            // Visualizza il nuovo grafico multi-linea
            renderAllPlayersChart(data, period);
        }

        /**
         * Funzione che crea o aggiorna un grafico con Chart.js.
         * @param {Array} data - I dati da tracciare.
         * @param {string} scope - "player" o "team".
         * @param {string} period - Il periodo di visualizzazione.
         */
        function renderChart(data, scope, period) {
            const ctx = document.getElementById('data-chart').getContext('2d');
            
            // Distrugge l'istanza precedente del grafico se esiste
            if (chartInstance) {
                chartInstance.destroy();
            }

            const labels = data.map(item => item.data);
            const values = data.map(item => item.valore);
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: scope === 'player' ? 'Valore Giocatore' : 'Valore Medio Team',
                        data: values,
                        borderColor: scope === 'player' ? 'rgb(59, 130, 246)' : 'rgb(16, 185, 129)',
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        tension: 0.3,
                        pointBackgroundColor: scope === 'player' ? 'rgb(59, 130, 246)' : 'rgb(16, 185, 129)',
                        spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Data'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Valore'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    }
                }
            });
        }
        
        /**
         * Funzione che crea o aggiorna un grafico di confronto (giocatore vs. team) con Chart.js.
         * @param {Array} playerData - Dati del giocatore.
         * @param {Array} teamData - Dati del team.
         * @param {string} player - Il nome del giocatore.
         * @param {string} period - Il periodo di visualizzazione.
         */
        function renderComparisonChart(playerData, teamData, player, period) {
            const ctx = document.getElementById('data-chart').getContext('2d');
            if (chartInstance) {
                chartInstance.destroy();
            }

            const combinedDates = Array.from(new Set([...playerData, ...teamData].map(item => item.sortableDate)))
                .sort((a, b) => new Date(a) - new Date(b));

            const labels = combinedDates.map(sortableDate => {
                const item = playerData.find(d => d.sortableDate === sortableDate) || teamData.find(d => d.sortableDate === sortableDate);
                return item ? item.data : '';
            });

            const playerValues = combinedDates.map(date => {
                const item = playerData.find(d => d.sortableDate === date);
                return item ? parseFloat(item.valore) : NaN;
            });
            const teamValues = combinedDates.map(date => {
                const item = teamData.find(d => d.sortableDate === date);
                return item ? parseFloat(item.valore) : NaN;
            });

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: player,
                        data: playerValues,
                        borderColor: 'rgb(59, 130, 246)', // Blu per il giocatore
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        tension: 0.3,
                        pointBackgroundColor: 'rgb(59, 130, 246)',
                        spanGaps: true
                    }, {
                        label: 'Media Team',
                        data: teamValues,
                        borderColor: 'rgb(16, 185, 129)', // Verde per il team
                        backgroundColor: 'rgba(16, 185, 129, 0.2)',
                        tension: 0.3,
                        pointBackgroundColor: 'rgb(16, 185, 129)',
                        spanGaps: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Data'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Valore'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    }
                }
            });
        }

        // NUOVA FUNZIONE: per generare un colore casuale ma distinto
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // NUOVA FUNZIONE: renderizza un grafico con più linee (una per ogni giocatore)
        function renderAllPlayersChart(data, period) {
            const ctx = document.getElementById('data-chart').getContext('2d');
            if (chartInstance) {
                chartInstance.destroy();
            }

            // Mappa i nomi dei giocatori a colori unici per consistenza
            const playerColors = {};
            const uniquePlayers = [...new Set(data.map(item => item.player))];
            uniquePlayers.forEach(p => {
                playerColors[p] = getRandomColor();
            });

            // Crea un dataset per ogni giocatore
            const datasets = uniquePlayers.map(p => {
                const playerData = data.filter(item => item.player === p);
                const values = playerData.map(item => parseFloat(item.valore));
                const color = playerColors[p];

                return {
                    label: p,
                    data: values,
                    borderColor: color,
                    backgroundColor: `${color}40`, // Aggiunge trasparenza
                    tension: 0.3,
                    pointBackgroundColor: color,
                    hidden: uniquePlayers.length > 10, // Nasconde le linee se ci sono troppi giocatori per evitare il disordine
                    spanGaps: true
                };
            });

            // Prepara le etichette dell'asse X (date uniche)
            const labels = [...new Set(data.map(item => item.data))];

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Data'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Valore'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 10,
                                padding: 10
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    }
                }
            });
        }


        // Funzioni di utilità per la formattazione e la gestione delle date
        function parseDate(dateString) {
            const parts = dateString.split('-');
            // Formato "gg-mm-aaaa" -> crea una data in UTC per evitare problemi di fuso orario
            return new Date(Date.UTC(parts[2], parts[1] - 1, parts[0])); 
        }

        function formatDateTo_ddMMyyyy(date) {
            const d = String(date.getUTCDate()).padStart(2, '0');
            const m = String(date.getUTCMonth() + 1).padStart(2, '0');
            const y = date.getUTCFullYear();
            return `${d}-${m}-${y}`;
        }
        
        function formatDateToAbbreviatedMonth(date) {
            const months = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            return `${months[date.getUTCMonth()]} ${date.getUTCFullYear()}`;
        }

        function getWeekNumberAndRange(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            
            const startOfWeek = new Date(d);
            startOfWeek.setUTCDate(d.getUTCDate() - (d.getUTCDay() || 7) + 1);
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setUTCDate(startOfWeek.getUTCDate() + 6);

            return `Settimana ${weekNo} (${formatDateTo_ddMMyyyy(startOfWeek)} - ${formatDateTo_ddMMyyyy(endOfWeek)})`;
        }
        
        /**
         * Visualizza un messaggio all'utente.
         * @param {string} message - Il messaggio da visualizzare.
         * @param {string} type - 'info' o 'error' per lo stile del messaggio.
         */
        function displayMessage(message, type) {
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            if (type === 'error') {
                messageBox.classList.remove('bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');
                messageBox.classList.add('bg-red-100', 'text-red-700');
            } else if (type === 'info') {
                messageBox.classList.remove('bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700');
                messageBox.classList.add('bg-blue-100', 'text-blue-700');
            }
        }
    </script>
</body>
</html>